# 速成版：


我们都知道，图片是由像素点构成的，而其最终的成像效果是由像素的颜色及数值所决定的。
下面这个6 * 6 的 excel 表格，由0，1两个数字构成，而如果我们把0看成黑色，把1看成白色，肉眼观察很像数字‘7’。而通过CNN（Convolutional Neural Networks)模型能告诉我们，这样一个6 * 6 的像素图是不是数字7，或者返回它属于数字0~9的概率分别是多少。
CNN模型：
==Step1 ：提取图片特征==
使用卷积核（也可以称作特征过滤器，即下图 3 * 3的像素图 ）提取图片特征。两个卷积核分别提取垂直特征和水平特征。
在卷积操作之前，先进行padding操作。
![image.png](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410061819193.png)

==Step2：最大池化 Max Pooling==
goal：将图片的数据更进步一步地压缩，仅反映出特征图中“最突出”的特点。
将6 * 6的特征图用2 * 2的网格分割成3 * 3的部分，然后提取每个部分的最大值，并放入最大池化后的3 * 3网格中。池化后的数据保留了原始图片中最精华的部分。

![230616f3814c04511d7d4b96837b01a.jpg](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410061817505.jpg)
![image.png](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410061818462.png)

Step3：扁平化处理
把池化后的特征图进行扁平化处理，把两个3 * 3的像素图叠加，转化成一维的“数据条”，数据条录入到后面的全连接隐藏层，最终产生输出结果。
![image.png](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410061823476.png)

扁平化之后的流程与ANN模型是完全一样的。
全连接隐藏层意味着任意一个神经元都与前后层的所有神经元相连接，确保最终的输出值是基于图片整体信息的结果。
而在最后的输出阶段，我们可以使用Sigmoid函数返回0~1的值代表该图片是7的概率。也可以使用SoftMax函数返回它分别属于0~9的概率。
现在，一个完整的CNN模型数据流就此完成。

# 完整版（补充ing）

### 卷积核（特征过滤器）

可以检测出垂直边缘的常用卷积核有：

![image.png](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410101630574.png)
可以检测出水平边缘的卷积核有：
将上述3个对应的图形顺时针旋转90度即可得到。
除了这些可以单纯检测出垂直抑或水平边缘的卷积核，还有其它能够检测出任意角度的边缘的卷积核。

### Padding

按照顺序提取原始图片中3 * 3的像素区域，再将其每个像素单元依次和卷积核内对应的像素单元相乘再求和，然后把结果记录在4 * 4的特征图上。
在特征图中，我们根据像素值的大小设置颜色的深浅。
观察可得，原始图片的垂直特征被很好地提取出来，而水平特征却没有被提取出来。
这是因为在特征提取计算过程中，像素图被降维（从6 * 6 到4 * 4），**边缘的特征消失**了。
![image.png](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410061820820.png)

这样直接用f * f的卷积核去做对初始数据（n * n)做卷积，会有两个不足。
注：此时每进行一次卷积操作，输出矩阵维度变换成（n-f+1) * (n-f+1)。
一个是每做一个卷积操作，图像就会缩小，经过多次卷积操作，输出结果可能会直接变为1 * 1。另一个是丢失掉了图像的边缘位置的信息。

因此为了解决这两个问题，我们使用Padding（填充）这个方法，这是一种扩充方法。
先将原始的6 * 6图像先扩充成8 * 8，扩充部分的像素值均被设置为0。然后再进行卷积操作。
这样在进行特征提取计算之后，转化后的特征图的像素仍为6 * 6，如此一来，水平和垂直的特征都得到了完美的提取。
注：此时每进行一次卷积操作，输出矩阵维度变换成（n+2p-f+1) * (n+2p-f+1)
(p指的是填充的像素点的层数)
![image.png](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410061819193.png)


term：
valid convolution : 不进行填充操作（也就是p=0）
same convolution : 进行填充操作并且是输出大小和输入大小相同。
注：在计算机视觉中，过滤器的 f 通常是奇数的，一个是在same convolution 当中，$p=\frac{f-1}{2}$ , f是奇数，p 刚好是一个整数。第二个原因是奇数维的过滤器有一个中心点，便于确定过滤器的位置。
（Ps:或许这俩都不是充分理由，但是在实际应用中，奇数维是惯例）。


### 步幅

过滤器从输入数组的最左上方开始，按从左往右、从上往下的顺序，依次在输入数组上滑动。这里将每次滑动的行数和列数称为步幅（stride）。
用f * f的卷积核去做对初始数据（n * n)做卷积，并且padding为p，stride为s，
这样可以推导出输出的维度为$[\frac{n+2p-f}{s}+1]$ x $[\frac{n+2p-f}{s}+1]$
方括号意味着将向下取整到最近的整数。

卷积核在进行卷积操作时，不能超出输入图象的边界，如果超出，只对输入图像的有效部分进行卷积，即忽略卷积核超出部分。所以计算卷积核维度时得进行向下取整的操作。

### 三维卷积
![image.png](https://erin-53347-1330131220.cos.ap-guangzhou.myqcloud.com/202410102059332.png)
原理和二维的相同，上图是用两个卷积核同时分别提取输入矩阵的水平和垂直特征的示例。

